package main

import (
	"context"
	"flag"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

{{range .Services}}
	"{{$.ImportPath}}/service/{{.PackageName}}"
{{end}}
)

func main() {
	var (
		httpAddr = flag.String("http.addr", ":8080", "HTTP listen address")
	)
	flag.Parse()

	// 创建日志记录器
	logger := log.New(os.Stdout, "{{range .Services}}{{.ServiceName}}{{end}} ", log.LstdFlags)

	// 创建服务实例
{{range .Services}}
	{{.PackageName}}Svc := {{.PackageName}}.NewService(nil)
{{end}}

	// 创建端点
{{range .Services}}
	{{.PackageName}}Endpoints := {{.PackageName}}.MakeServerEndpoints({{.PackageName}}Svc, logger)
{{end}}

	// 创建 HTTP 处理器
{{if .NeedMux}}
	// 多服务使用多路复用器
	mux := http.NewServeMux()
	{{range .Services}}mux.Handle("/{{.PackageName}}/", {{.PackageName}}.NewHTTPHandler({{.PackageName}}Endpoints))
	{{end}}
	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})
{{else}}
	{{range .Services}}handler := {{.PackageName}}.NewHTTPHandler({{.PackageName}}Endpoints){{end}}
{{end}}

	// 创建 HTTP 服务器
{{if .NeedMux}}
	httpServer := &http.Server{
		Addr:    *httpAddr,
		Handler: mux,
	}
{{else}}
	{{range .Services}}httpServer := &http.Server{
		Addr:    *httpAddr,
		Handler: handler,
	}{{end}}
{{end}}

	// 启动服务器
	go func() {
		logger.Printf("transport=HTTP addr=%s", *httpAddr)
		if err := httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			logger.Fatalf("HTTP server failed: %v", err)
		}
	}()

	// 优雅关闭
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	logger.Println("Shutting down server...")

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	if err := httpServer.Shutdown(ctx); err != nil {
		logger.Fatalf("Server shutdown failed: %v", err)
	}

	logger.Println("Server exited")
}