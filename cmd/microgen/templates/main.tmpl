package main

import (
	"context"
	"flag"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

{{range .Services}}	"{{$.ImportPath}}/service/{{.PackageName}}"
	{{.PackageName}}Endpoint "{{$.ImportPath}}/endpoint/{{.PackageName}}"
	{{.PackageName}}Transport "{{$.ImportPath}}/transport/{{.PackageName}}"
{{end}}
)

func main() {
	var (
		httpAddr = flag.String("http.addr", ":8080", "HTTP listen address")
	)
	flag.Parse()

	// 创建日志记录器
	logger := log.New(os.Stdout, "{{range .Services}}{{.ServiceName}}{{end}} ", log.LstdFlags)

	// 创建服务实例
{{range .Services}}	{{.PackageName}}Svc := {{.PackageName}}.NewService(nil)
{{end}}

	// 创建端点
{{range .Services}}	{{.PackageName}}Endpoints := {{.PackageName}}Endpoint.MakeServerEndpoints({{.PackageName}}Svc, logger)
{{end}}

	// 创建 HTTP 处理器
{{if .NeedMux}}	// 多服务使用多路复用器
	mux := http.NewServeMux()
{{range .Services}}	mux.Handle("/{{.PackageName}}/", {{.PackageName}}Transport.NewHTTPHandler({{.PackageName}}Endpoints))
{{end}}
	
	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})

	httpHandler := mux
{{else}}	// 单服务直接使用处理器
	httpHandler := {{index .Services 0}}Transport.NewHTTPHandler({{index .Services 0}}Endpoints)
{{end}}

	// 创建 HTTP 服务器
	httpServer := &http.Server{
		Addr:    *httpAddr,
		Handler: httpHandler,
	}

	// 启动服务器
	go func() {
		logger.Printf("transport=HTTP addr=%s", *httpAddr)
		if err := httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			logger.Fatalf("HTTP server failed: %v", err)
		}
	}()

	// 优雅关闭
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	logger.Println("Shutting down server...")

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	if err := httpServer.Shutdown(ctx); err != nil {
		logger.Fatalf("Server shutdown failed: %v", err)
	}

	logger.Println("Server exited")
}